ASM（Assembly Language，汇编语言）是一种低级编程语言，直接与计算机硬件交互。它是介于机器语言和高级语言之间的语言，用于为特定的处理器架构（如 x86、ARM、RISC-V）编写程序。汇编语言通过助记符和符号表示机器指令，能够直接控制硬件，因此具有高效性和灵活性。

常见命令(x86)：
以下是 **x86 架构**中一些常见的汇编指令，分为不同的功能类别进行介绍，每条指令都附有简单解释和使用示例。

---

### 1. **数据传输指令**

| 指令       | 功能                               | 示例                          |
|------------|------------------------------------|-------------------------------|
| `MOV`      | 数据传送，将数据从源复制到目的地   | `MOV AX, BX` 将 BX 的值复制到 AX |
| `PUSH`     | 将数据压入栈                       | `PUSH AX` 将 AX 的值压入栈    |
| `POP`      | 从栈中弹出数据到指定位置           | `POP BX` 从栈顶弹出值到 BX    |
| `XCHG`     | 交换两个操作数的值                 | `XCHG AX, BX` 交换 AX 和 BX 的值 |
| `LEA`      | 取有效地址                         | `LEA BX, [SI+4]` 将 [SI+4] 的地址存入 BX |
| `LAHF`     | 加载标志寄存器中的低字节到 AH 中   | `LAHF`                        |
| `SAHF`     | 将 AH 中的内容存入标志寄存器       | `SAHF`                        |

---

### 2. **算术运算指令**

| 指令       | 功能                               | 示例                          |
|------------|------------------------------------|-------------------------------|
| `ADD`      | 加法运算                           | `ADD AX, BX` AX = AX + BX     |
| `SUB`      | 减法运算                           | `SUB AX, BX` AX = AX - BX     |
| `INC`      | 将操作数加 1                       | `INC AX` AX = AX + 1          |
| `DEC`      | 将操作数减 1                       | `DEC AX` AX = AX - 1          |
| `MUL`      | 无符号乘法                         | `MUL BX` AX = AX * BX         |
| `IMUL`     | 有符号乘法                         | `IMUL BX` AX = AX * BX        |
| `DIV`      | 无符号除法                         | `DIV BX` AX / BX，余数存入 DX |
| `IDIV`     | 有符号除法                         | `IDIV BX` AX / BX，余数存入 DX |
| `NEG`      | 取反（变为负数）                   | `NEG AX`                      |
| `ADC`      | 带进位加法                         | `ADC AX, BX`                  |
| `SBB`      | 带借位减法                         | `SBB AX, BX`                  |

---

### 3. **逻辑运算指令**

| 指令       | 功能                               | 示例                          |
|------------|------------------------------------|-------------------------------|
| `AND`      | 按位与                             | `AND AX, BX`                  |
| `OR`       | 按位或                             | `OR AX, BX`                   |
| `XOR`      | 按位异或                           | `XOR AX, BX`                  |
| `NOT`      | 按位取反                           | `NOT AX`                      |
| `TEST`     | 按位与测试，不改变操作数           | `TEST AX, BX`                 |
| `SHL`      | 逻辑左移                           | `SHL AX, 1`                   |
| `SHR`      | 逻辑右移                           | `SHR AX, 1`                   |
| `SAR`      | 算术右移                           | `SAR AX, 1`                   |
| `ROL`      | 循环左移                           | `ROL AX, 1`                   |
| `ROR`      | 循环右移                           | `ROR AX, 1`                   |

---

### 4. **控制流指令**

| 指令       | 功能                               | 示例                          |
|------------|------------------------------------|-------------------------------|
| `JMP`      | 无条件跳转                         | `JMP LABEL` 跳转到 LABEL      |
| `JE/JZ`    | 等于/零时跳转                      | `JE LABEL`                    |
| `JNE/JNZ`  | 不等于/非零时跳转                  | `JNE LABEL`                   |
| `JG/JNLE`  | 大于时跳转                         | `JG LABEL`                    |
| `JL/JNGE`  | 小于时跳转                         | `JL LABEL`                    |
| `JGE/JNL`  | 大于等于时跳转                     | `JGE LABEL`                   |
| `JLE/JNG`  | 小于等于时跳转                     | `JLE LABEL`                   |
| `CALL`     | 调用子程序                         | `CALL SUBROUTINE`             |
| `RET`      | 从子程序返回                       | `RET`                         |
| `LOOP`     | 循环跳转（CX 计数器非零时跳转）    | `LOOP LABEL`                  |

---

### 5. **堆栈操作指令**

| 指令       | 功能                               | 示例                          |
|------------|------------------------------------|-------------------------------|
| `PUSH`     | 将数据压入栈                       | `PUSH AX`                     |
| `POP`      | 从栈中弹出数据到寄存器             | `POP BX`                      |
| `PUSHF`    | 将标志寄存器压入栈                 | `PUSHF`                       |
| `POPF`     | 从栈中恢复标志寄存器               | `POPF`                        |
| `ENTER`    | 创建栈帧，用于过程调用             | `ENTER 4, 0`                  |
| `LEAVE`    | 清理栈帧，配合 `ENTER` 使用        | `LEAVE`                       |

---

### 6. **字符串操作指令**

| 指令       | 功能                               | 示例                          |
|------------|------------------------------------|-------------------------------|
| `MOVS`     | 复制字符串                         | `MOVS BYTE PTR [DI], [SI]`    |
| `CMPS`     | 比较字符串                         | `CMPS BYTE PTR [DI], [SI]`    |
| `SCAS`     | 扫描字符串                         | `SCAS BYTE PTR [DI]`          |
| `LODS`     | 加载字符串到累加器                 | `LODS BYTE PTR [SI]`          |
| `STOS`     | 存储字符串从累加器到内存           | `STOS BYTE PTR [DI]`          |
| `REP`      | 重复执行某字符串指令（计数器 CX）  | `REP MOVSB`                   |

---

### 7. **中断指令**

| 指令       | 功能                               | 示例                          |
|------------|------------------------------------|-------------------------------|
| `INT`      | 触发中断                          | `INT 21H` 调用 DOS 中断功能   |
| `IRET`     | 从中断返回                        | `IRET`                        |
| `IN`       | 从 I/O 端口读取                   | `IN AL, 60h`                  |
| `OUT`      | 向 I/O 端口写入                   | `OUT 60h, AL`                 |

